{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Numbat Tasks","text":"<p>A self-hosted to-do list app</p> <p></p>"},{"location":"#why-another-to-do-list-app","title":"Why another to-do list app","text":"<p>Numbat tasks aims to be a personal to-do list app in the Goldilocks zone between too simple and too complex.  There are thousands of half built to-do list apps out there, usually with about 3 commits last touched 5 years ago. There is a handful of  well-supported and maintained projects, but many of them say things like \"Jira replacement with Kanban boards,  gantt chart, and burndown charts that the whole team can use\". </p> <p>I wanted a privacy-friendly place to put my shopping list that I felt comfortable exposing to the internet.</p> <p>Plus, nothing says \"procrastinating\" like building a massively over-engineered to-do list app, rather than actually doing things.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>Want to give it a go? see getting started</p>"},{"location":"environment_variables/","title":"Environment Variables","text":"<p>All environment variables and what they do</p>"},{"location":"environment_variables/#allowed_hosts","title":"ALLOWED_HOSTS","text":"<p>Default: <code>\"\"</code> (empty string)</p> <p>Allowed host names that the API will accept, it can be a single value <code>example.com</code> or a comma seperated list of values <code>example.com, tasks.example.com, example.org</code> see Django's documentation for more details.</p>"},{"location":"environment_variables/#debug","title":"DEBUG","text":"<p>Default: <code>False</code></p> <p>Debug should only be used in development, it is used to enable live reloading in the API, Frontend, and Documentation containers.</p>"},{"location":"environment_variables/#postgres_db","title":"POSTGRES_DB","text":"<p>Default: <code>numbat_tasks</code></p> <p>Name of the postgres database, this will be automatically created when bringing up the containers for the first time.</p>"},{"location":"environment_variables/#postgres_host","title":"POSTGRES_HOST","text":"<p>Default: <code>database</code></p> <p>Used to specify the domain name of the database host, when using docker compose the host name will be automatically set to the name of the container, but could be used if the database host was on a different machine.</p>"},{"location":"environment_variables/#postgres_password","title":"POSTGRES_PASSWORD","text":"<p>Default: <code>\"\"</code> (empty string)</p> <p>This should be randomly generated, any password generator will do, or for convenience you can run</p> <pre><code>echo POSTGRES_PASSWORD=$(dd if=/dev/urandom bs=1 count=18 status=none | base64) &gt;&gt; .env\n</code></pre>"},{"location":"environment_variables/#postgres_port","title":"POSTGRES_PORT","text":"<p>Default: <code>5432</code></p> <p>Port for postgres server, you shouldn't need to change this unless you are running postgres on a non-standard port.</p>"},{"location":"environment_variables/#postgres_user","title":"POSTGRES_USER","text":"<p>Default: <code>numbat</code></p> <p>User to connect to postgres with.</p>"},{"location":"environment_variables/#secret_key","title":"SECRET_KEY","text":"<p>Default: <code>\"\"</code> (empty string)</p> <p>The secret key is used by the API for things like signing JWTs for more information see Django's documentation.</p> <p>The api will refuse to start if the secret key is blank or contains the string <code>insecure</code> (key used in development).</p> <p>A key can be generated with</p> <pre><code>echo SECRET_KEY=$(dd if=/dev/urandom bs=1 count=42 status=none | base64) &gt;&gt; .env\n</code></pre>"},{"location":"environment_variables/#signup_enabled","title":"SIGNUP_ENABLED","text":"<p>Default: <code>false</code></p> <p>When enabled, new users can sign up.</p> <p>Warning</p> <p>Signups are functional, but not really production ready. There is no validation of email address (e.g. Click link to verify your address) and no self-service password reset (typed your password wrong during signup? bad luck).</p> <p>Note</p> <p>Even when this is disabled, the first use can still sign up as part of the initial setup.</p>"},{"location":"environment_variables/#uv_project_environment","title":"UV_PROJECT_ENVIRONMENT","text":"<p>Default: <code>/venv</code></p> <p>Specifies the path for the uv virtual environment. Only really relent during development.</p>"},{"location":"environment_variables/#version","title":"VERSION","text":"<p>Default: <code>\"\"</code> (empty string)</p> <p>Not used in the docker containers directly, but by docker compose to select the correct image to pull down and run.</p>"},{"location":"environment_variables/#vite_api_base_url","title":"VITE_API_BASE_URL","text":"<p>Default: <code>\"\"</code> (empty string)</p> <p>URL for the api, this can be a full domain name for example you could have the frontend hosted by a CDN at <code>https://tasks.example.com/</code> and the API on a different server at <code>https://api.example.com/</code>. Although then you would need to set up Django CORS headers which is not implemented yet.</p>"},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#getting-started","title":"Getting started","text":"<p>The recommended way to get set up is with docker compose. At least some level of familiarity with docker compose and self-hosting is assumed.</p> <p>This guide is for running on http://localhost:8000 behind a reverse proxy. However, it should be easy to adapt to serving the files directly with Caddy.</p> <p>To get started there are 3 files needed:</p> <ul> <li>docker-compose.yml</li> <li>.env</li> <li>Caddyfile</li> </ul>"},{"location":"getting_started/#docker-composeyml","title":"docker-compose.yml","text":"<p>The main file to specify which docker containers to run. Once set up, this file shouldn't need to change for releases.</p> docker-compose.yml<pre><code>name: numbat-tasks # (1)!\n\nservices:\n    api:\n        image: ghcr.io/hybridau/numbat-tasks-api:$VERSION\n        env_file:\n            - .env\n        depends_on:\n            database:\n                condition: service_started\n        volumes:\n            - static_files:/static_files\n        restart: always\n    database:\n        image: postgres:18-trixie\n        volumes:\n            - postgres_data:/var/lib/postgresql/\n        env_file:\n            - .env\n        restart: always\n    frontend: # (2)!\n        image: ghcr.io/hybridau/numbat-tasks-frontend:$VERSION\n        volumes:\n          - static_files:/static_files\n        env_file:\n            - .env\n    caddy:\n        image: caddy:2-alpine\n        ports: # (3)!\n            - \"127.0.0.1:8000:80\" \n        volumes:\n            - ./Caddyfile:/etc/caddy/Caddyfile:ro\n            - caddy_data:/data\n            - caddy_config:/config\n            - static_files:/static_files:ro\n        restart: always\n\nvolumes:\n    postgres_data:\n    caddy_data:\n    caddy_config:\n    static_files:\n</code></pre> <ol> <li>This is used to keep all the containers and volumes in their own spaces, so you can have a different project with    a volume called <code>postgres_data</code> and it won't conflict with this one.</li> <li>The frontend docker container will start, build the static files, write them out to <code>/static_files/frontend</code> and then    exit. Caddy will continue to serve the files.</li> <li>To serve the site directly rather than behind a reverse proxy, change this to    <pre><code>ports:\n  - \"80:80\" \n  - \"443:443\" \n</code></pre></li> </ol>"},{"location":"getting_started/#env","title":".env","text":"<p>All the settings should live in here. The following is the minimum configuration, but a list of all environment variables is available.</p> .env<pre><code>VERSION=latest  # (1)! \n\n\n# Reasonable defaults\nPOSTGRES_DB=numbat_tasks\nPOSTGRES_USER=numbat\n\n# Must be changed for prod\nALLOWED_HOSTS=tasks.example.com\n# echo POSTGRES_PASSWORD=$(dd if=/dev/urandom bs=1 count=18 status=none | base64) &gt;&gt; .env\n# echo SECRET_KEY=$(dd if=/dev/urandom bs=1 count=42 status=none | base64) &gt;&gt; .env\n</code></pre> <ol> <li>You can also pin to a specific version number e.g. <code>VERSION=1.2.3</code></li> </ol>"},{"location":"getting_started/#caddyfile","title":"Caddyfile","text":"Caddyfile<pre><code>:80 { # (1)!\n    handle_path /api/static/* {\n        root * /static_files/api\n        file_server\n    }\n    handle /api/admin/* {  # (2)!\n        # Block any IP address not on the allow list from accessing the Django admin console\n        @blocked not remote_ip 10.1.1.16\n        respond @blocked \"Access Denied\" 403\n        reverse_proxy api:8000\n    }\n    handle /api/* {\n        reverse_proxy api:8000\n    }\n    handle /assets/* {\n        root * /static_files/frontend\n        file_server\n    }\n    handle {\n        root * /static_files/frontend\n        file_server\n        route {\n            try_files {path} /index.html\n            header /index.html Cache-Control \"public, no-cache, max-age=0, must-revalidate\"\n        }\n    }\n}\n</code></pre> <ol> <li> <p>To serve the site directly, change this to     <pre><code>tasks.example.com {\n   ...\n</code></pre></p> </li> <li> <p>Restricting the Django admin console to specific IPs optional, but encouraged</p> </li> </ol>"},{"location":"getting_started/#running","title":"Running","text":"<p>Place those three files in the same directory and to start the site run <pre><code>docker compose up -d\n</code></pre></p>"},{"location":"getting_started/#create-a-user-and-login","title":"Create a user and login","text":"<p>You can now navigate to the site, you should be directed to the signup page to create an account.</p> <p>See user management for steps on creating and managing more users.</p>"},{"location":"getting_started/#delete-everything-and-start-again","title":"Delete everything and start again","text":"<p>Warning</p> <p>This will permanently delete everything. All users, all lists, all tasks, everything.</p> <pre><code>docker compose down --volumes\n</code></pre>"},{"location":"useful_urls/","title":"Useful URLs","text":"<p>These urls are given assuming the site is running on localhost on port 8000. </p>"},{"location":"useful_urls/#frontend-login","title":"Frontend login","text":"<p>http://localhost:8000/sign-in</p>"},{"location":"useful_urls/#api-django-admin-console","title":"API Django admin console","text":"<p>http://localhost:8000/api/admin</p>"},{"location":"useful_urls/#swagger-docs","title":"Swagger docs","text":"<p>Documentation for API endpoints</p> <p>http://localhost:8000/api/schema/swagger</p> <p>To download the schema as a <code>.yaml</code> file (e.g. to load into Postman or similar tools)</p> <p>http://localhost:8000/api/schema/</p>"},{"location":"useful_urls/#documentation","title":"Documentation","text":"<p>Assuming you have the docs server running.</p> <p>http://localhost:8000/docs/</p>"},{"location":"user_management/","title":"User Management","text":""},{"location":"user_management/#the-first-user","title":"The first user","text":"<p>The first user to sign up to a numbat tasks instance will be marked as a \"superuser\". This user can  manage other users, create new accounts, reset passwords, and delete accounts.</p> <p>One user can sign up even with the <code>SIGNUP_ENABLED</code> environment variable is set to false (the default)</p> <p>The API endpoints exist for user management, however a nice GUI through the frontend is still on the to-do list, so for now the Django admin console is the only way to manage users.</p> <p>While the first user to sign up is a superuser, they do not get the \"staff\" status, this is by design as long term we don't want users to have to log into the Django admin console. However, for now we will need to create a superuser with the staff status.</p>"},{"location":"user_management/#create-a-superuser-with-the-staff-status","title":"Create a superuser with the staff status","text":"<p>This will create a superuser that can log in to the Django admin console.</p> <pre><code>docker compose exec -it api /venv/bin/python /api/manage.py createsuperuser\n</code></pre>"},{"location":"user_management/#create-and-manage-other-users","title":"Create and manage other users","text":"<p>Once the superuser has been created, log in to the admin panel  and from there you can create/update/delete other users (and tasks)</p>"}]}